#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"

double **inputMatrix1, **inputMatrix2, **outputMatrixSeq, **outputMatrixPar;
int size, numThreads;

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 */
void mmm_init() {
	// TODO
	inputMatrix1 = (double**) malloc(sizeof(double*) * size);
	inputMatrix2 = (double**) malloc(sizeof(double*) * size);
	outputMatrixSeq = (double**) malloc(sizeof(double*) * size);
	outputMatrixPar = (double**) malloc(sizeof(double*) * size);

	// Allocate the matrices
	for (int i = 0; i < size; i++) {
    	inputMatrix1[i] = (double*) malloc(sizeof(double) * size);
		inputMatrix2[i] = (double*) malloc(sizeof(double) * size);
		outputMatrixSeq[i] = (double*) malloc(sizeof(double) * size);
		outputMatrixPar[i] = (double*) malloc(sizeof(double) * size);
	}


	srand(time(NULL)); // Seed using the current time
	double randomNumber;

	// Populate the first input matrix
	for (int i=0; i < size; i++) {
		for (int j=0; j < size; j++) {
			randomNumber = (double) rand() / RAND_MAX * 99; // Generates a random double
			inputMatrix1[i][j] = randomNumber;
		}
	}

	// Populate the second input matrix
	for (int i=0; i < size; i++) {
		for (int j=0; j < size; j++) {
			randomNumber = (double) rand() / RAND_MAX * 99; // Generates a random double
			inputMatrix2[i][j] = randomNumber;
		}
	}

}

/**
 * Reset a given matrix to zeroes
 * @param matrix pointer to a 2D array
 */
void mmm_reset(double **matrix) {
	// TODO
	for (int i=0; i < size; i++) {
		for (int j=0; j < size; j++) {
			matrix[i][j] = 0;
		}
	}
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup() {
	// TODO
	for (int i=0; i < size; i++) {
		free(inputMatrix1[i]);
		free(inputMatrix2[i]);
		free(outputMatrixSeq[i]);
		free(outputMatrixPar[i]);
		inputMatrix1[i] = NULL;
		inputMatrix2[i] = NULL;
		outputMatrixSeq[i] = NULL;
		outputMatrixPar[i] = NULL;
	}

	free(inputMatrix1);
	free(inputMatrix2);
	free(outputMatrixPar);
	free(outputMatrixSeq);
	inputMatrix1 = NULL;
	inputMatrix2 = NULL;
	outputMatrixPar = NULL;
	outputMatrixSeq = NULL;
}

/**
 * Sequential MMM
 */
void mmm_seq() {
	// TODO - code to perform sequential MMM
	for (int i = 0; i < size; i++) {
    	for (int j = 0; j < size; j++) {
        	int sum = 0;
        	for (int k = 0; k < size; k++) {
            	sum += inputMatrix1[i][k] * inputMatrix2[k][j];
        	}
        	outputMatrixSeq[i][j] = sum;
	    }
	}
}

/**
 * Parallel MMM
 */
void *mmm_par(void *args) {
	// TODO - code to perform parallel MMM

	thread_args* input = (thread_args*) args;

	for (int i=input->start-1; i<= input->end-1; i++) {
		for (int j = 0; j < size; j++) {
        	int sum = 0;
        	for (int k = 0; k < size; k++) {
            	sum += inputMatrix1[i][k] * inputMatrix2[k][j];
        	}
        	outputMatrixPar[i][j] = sum;
	    }
	}

	return NULL;
}	

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify() {
	// TODO

	double maxDifference = 0.0; // Difference to calculate for

	for (int i=0; i<size; i++) {
		for (int j=0; j<size; j++) {
			double difference = abs(outputMatrixPar[i][j] - outputMatrixSeq[i][j]);
			if (difference > maxDifference) {
				maxDifference = difference;
			}
		}
	}
	return maxDifference;
}
